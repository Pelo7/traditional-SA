"""RTA Modul"""

def _compute_response_time(new_task, num_elements, check_task, taskset):
    global _response_time_old, _response_time, _first_task
    _response_time_old = check_task.executionTime
    while True:
        _curr_task = taskset[0]
        _curr_task_idx = 0
        _response_time = check_task.executionTime
        for i in range(num_elements):
            _response_time += math.ceil(_response_time_old / _curr_task.period) * \
                              _curr_task.executionTime
            _curr_task_idx += 1
            _curr_task = taskset[_curr_task_idx]

        # If check_task is another task then new_task we have to add the new_task here
        if new_task != check_task:
            _response_time += math.ceil(_response_time_old / new_task.period) * \
                              new_task.executionTime

        print("response_time = {0:d}, response_time_old = {1:d}, deadline = {2:d}"
              .format(_response_time, _response_time_old, check_task.deadline))

        ''' Since the response_time is increasing with each iteration, it has to be always smaller
        then the deadline -> we can stop if we hit the deadline. '''
        if _response_time > check_task.deadline:
            # Task-Set is NOT schedulable
            print("Task-Set is NOT schedulable!")
            return False
        if _response_time_old >= _response_time:
            if _response_time <= check_task.deadline:
                # Task-Set is schedulable
                print("Task-Set is schedulable! Response time = {0:d}, deadline = {1:d}"
                      .format(_response_time, check_task.deadline))
        _response_time_old = _response_time


def RTA(new_task, rq_buf):
    global _response_time_old, _response_time, _first_task

    num_elements = len(rq_buf)
    print("num_elements = ", num_elements)

    ''' Assuming that each task is schedulable if it is alone, the task is accepted if the rq_buf
    is empty.'''
    if num_elements == 0:
        print("num_elements == 0, Task-Set is schedulable!")
        return True

    ''' RTA-Algorithm
    We assume that the existing Task-Set is schedulable without the new task. Therefore the
    response time has to e computed for the new task and all tasks having a smaller priority then
    the new task and for the new task. The tasks in the rq_buf are assumed to be sorted by
    priorities. '''
    _first_task = rq_buf[0]
    print("_first_task = ",  _first_task)
    _curr_task = _first_task
    print("_curr_task = ", _curr_task)
    print("new_task.priority=", new_task.priority, " ? rq_buf[-1].priority=", rq_buf[-1].priority)
    '''if new_task.priority < rq_buf[-1].priority:
        print("New task hast lower priority the all other tasks, priority_new = {0:d}, \
              priority_last = {1:d}".format(new_task.priority, rq_buf[-1].priority))
        _response_time_old = new_task.executionTime
        if not _compute_response_time(new_task, num_elements, new_task):
            # Task-Set is not schedulable
            print("Task-Set is not schedulable!")
            return False
    else:
        # Compute response time for all tasks having priority smaller then the new task.
        print("New task has higher or the same priority then lowest existing task, priority_new = \
              {01:d}, priority_last = {1:d}".format(new_task.priority, rq_buf[-1].priority))
        for i in range(num_elements):
            _response_time_old = _curr_task.executionTime
            if _curr_task.priority <= new_task.priority:
                if not _compute_response_time(new_task, i, _curr_task, rq_buf):
                    # Task-Set is not schedulable
                    return False

            # Check new_task at right position
            if _curr_task.priority > new_task.priority and (_curr_task+1).priority <= \
               new_task.priority and i > 0:
                if not _compute_response_time(new_task, i+1, new_task):
                    # Task-Set is not schedulable
                    print("Task-Set is not schedulable!")
                    return False
            _curr_task += 1
    print("All Task-Sets passed the RTA Algorithm -> Task-Set schedulable!")
    return True'''


if __name__ == "__main__":
    # Configure logging: format should be "LEVELNAME: Message",
    # logging level should be DEBUG (all messages are shown)
    logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.INFO)

    db_connection = db.openDb(db.db_name)  # Open database
    db_cursor = db_connection.cursor()  # Create a cursor for database

    # Read execution times depending on PKG and save as dictionary
    dict_C = {}  # Empty dictionary
    # Iterate over all table rows
    for row in db_cursor.execute("SELECT * FROM ExecutionTimes"):
        dict_C[row[0]] = row[1]  # Add entry "PKG" : "Execution Time"

    table_name = "Dataset3"  # Name of the table

    # Get number of columns of the table
    db_cursor.execute("PRAGMA table_info('" + table_name + "')")
    numberOfColumns = len(db_cursor.fetchall())

    # Calculate number of tasks in dataset
    # -2 for Set_ID and Exit_Value
    # /8 because each task has 8 properties
    numberOfTasks = int((numberOfColumns - 2) / 8)

    row_counter = 0

    # Read out the table and perform the test for each taskset in table
    for row in db_cursor.execute("SELECT * FROM " + table_name):
        if row_counter <= 10:
            taskset = TaskSet()  # Empty taskset
            schedulability = None
            # Iterate over all tasks
            for i in range(numberOfTasks):
                C = dict_C[row[4 + i * 8]]  # Execution time of task i
                new_task = Task(priority=row[1 + i * 8], deadline=row[2 + i * 8],
                                quota=row[3 + i * 8], pkg=row[4 + i * 8], arg=row[5 + i * 8],
                                period=row[6 + i * 8], numberOfJobs=row[7 + i * 8],
                                offset=row[8 + i * 8], executionTime=C)
                schedulability = fp_sufficient_test(new_task, taskset)
                # schedulability = RTA(new_task, taskset)
                logging.debug("Schedulability = " + str(schedulability))
                taskset.addTask(new_task)
            if schedulability == True:
                print("Task-Set is schedulable!")
            else:
                print("Task-Set is NOT schedulable!")
            row_counter += 1

    db.closeDb(db_connection)  # Close database
